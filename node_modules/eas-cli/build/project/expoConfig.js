"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicExpoConfig = exports.isUsingStaticExpoConfig = exports.ensureExpoConfigExists = exports.getPrivateExpoConfig = exports.createOrModifyExpoConfigAsync = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const json_file_1 = tslib_1.__importDefault(require("@expo/json-file"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const joi_1 = tslib_1.__importDefault(require("joi"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const path_1 = tslib_1.__importDefault(require("path"));
async function createOrModifyExpoConfigAsync(projectDir, exp, readOptions) {
    ensureExpoConfigExists(projectDir);
    await ensureStaticExpoConfigIsValidAsync(projectDir);
    if (readOptions) {
        return (0, config_1.modifyConfigAsync)(projectDir, exp, readOptions);
    }
    else {
        return (0, config_1.modifyConfigAsync)(projectDir, exp);
    }
}
exports.createOrModifyExpoConfigAsync = createOrModifyExpoConfigAsync;
function getExpoConfigInternal(projectDir, opts = {}) {
    const originalProcessEnv = process.env;
    try {
        process.env = {
            ...process.env,
            ...opts.env,
        };
        const { exp } = (0, config_1.getConfig)(projectDir, {
            skipSDKVersionRequirement: true,
            ...(opts.isPublicConfig ? { isPublicConfig: true } : {}),
        });
        const { error } = MinimalAppConfigSchema.validate(exp, {
            allowUnknown: true,
            abortEarly: true,
        });
        if (error) {
            throw new Error(`Invalid app config.\n${error.message}`);
        }
        return exp;
    }
    finally {
        process.env = originalProcessEnv;
    }
}
const MinimalAppConfigSchema = joi_1.default.object({
    slug: joi_1.default.string().required(),
    name: joi_1.default.string().required(),
    version: joi_1.default.string(),
    android: joi_1.default.object({
        versionCode: joi_1.default.number().integer(),
    }),
    ios: joi_1.default.object({
        buildNumber: joi_1.default.string(),
    }),
});
function getPrivateExpoConfig(projectDir, opts = {}) {
    ensureExpoConfigExists(projectDir);
    return getExpoConfigInternal(projectDir, { ...opts, isPublicConfig: false });
}
exports.getPrivateExpoConfig = getPrivateExpoConfig;
function ensureExpoConfigExists(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    if (!paths?.staticConfigPath && !paths?.dynamicConfigPath) {
        // eslint-disable-next-line node/no-sync
        fs_extra_1.default.writeFileSync(path_1.default.join(projectDir, 'app.json'), JSON.stringify({ expo: {} }, null, 2));
    }
}
exports.ensureExpoConfigExists = ensureExpoConfigExists;
async function ensureStaticExpoConfigIsValidAsync(projectDir) {
    if (isUsingStaticExpoConfig(projectDir)) {
        const staticConfigPath = (0, nullthrows_1.default)((0, config_1.getConfigFilePaths)(projectDir).staticConfigPath);
        const staticConfig = await json_file_1.default.readAsync(staticConfigPath);
        // Add the "expo" key if it doesn't exist on app.json yet, such as in
        // projects initialized with RNC CLI
        if (!staticConfig?.expo) {
            staticConfig.expo = {};
            await json_file_1.default.writeAsync(staticConfigPath, staticConfig);
        }
    }
}
function isUsingStaticExpoConfig(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    return !!(paths.staticConfigPath?.endsWith('app.json') && !paths.dynamicConfigPath);
}
exports.isUsingStaticExpoConfig = isUsingStaticExpoConfig;
function getPublicExpoConfig(projectDir, opts = {}) {
    ensureExpoConfigExists(projectDir);
    return getExpoConfigInternal(projectDir, { ...opts, isPublicConfig: true });
}
exports.getPublicExpoConfig = getPublicExpoConfig;
