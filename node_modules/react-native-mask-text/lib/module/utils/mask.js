/* eslint-disable no-confusing-arrow */
import { BigNumber } from 'bignumber.js';
import toPattern from './toPattern';
/**
 * function unMask(
 * @param {string} value
 * @param {'custom' | 'currency'} type
 * @returns {string}
 */

function unMask(value) {
  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom';

  if (type === 'currency') {
    if (!value) return '0';
    const unMaskedValue = value.replace(/\D/g, '');
    const number = parseInt(unMaskedValue.trimStart());
    return number.toString();
  }

  return value.replace(/\W/g, '');
}
/**
 * function masker(
 * @param {string} value
 * @param {string} patterns
 * @param {any} options
 * @returns {string}
 */


function masker(value, pattern, options) {
  return toPattern(value, {
    pattern,
    ...options
  });
}
/**
 * function masker(
 * @param {string} value
 * @param {any} options
 * @returns {string}
 */


function currencyMasker() {
  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
  let options = arguments.length > 1 ? arguments[1] : undefined;
  const {
    prefix,
    decimalSeparator,
    groupSeparator,
    precision,
    groupSize,
    secondaryGroupSize,
    fractionGroupSeparator,
    fractionGroupSize,
    suffix
  } = options;
  const precisionDivider = parseInt(1 + '0'.repeat(precision || 0));
  const number = parseInt(value) / precisionDivider;
  const formatter = {
    prefix,
    decimalSeparator,
    groupSeparator,
    groupSize: groupSize || 3,
    secondaryGroupSize,
    fractionGroupSeparator,
    fractionGroupSize,
    suffix
  };
  const bigNumber = new BigNumber(number);
  BigNumber.config({
    FORMAT: formatter
  });
  return bigNumber.toFormat(precision);
}
/**
 * function multimasker(
 * @param {string} value
 * @param {string[]} patterns
 * @param {any} options
 * @returns {string}
 */


function multimasker(value, patterns, options) {
  return masker(value, patterns.reduce((memo, pattern) => value.length <= unMask(memo).length ? memo : pattern, patterns[0]), options);
}
/**
 * function mask(
 * @param {string} value
 * @param {string | string[]} patterns
 * @param {'custom' | 'currency'} type
 * @param {any} options
 * @returns {string}
 */


function mask(value) {
  let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'custom';
  let options = arguments.length > 3 ? arguments[3] : undefined;

  if (type === 'currency') {
    return currencyMasker(String(value), options);
  }

  if (typeof pattern === 'string') {
    return masker(String(value), pattern || '', {});
  }

  return multimasker(String(value), pattern, {});
}

export { mask, unMask };
//# sourceMappingURL=mask.js.map