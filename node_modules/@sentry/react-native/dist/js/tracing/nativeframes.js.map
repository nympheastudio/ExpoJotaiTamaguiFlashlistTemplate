{"version":3,"file":"nativeframes.js","sourceRoot":"","sources":["../../../src/js/tracing/nativeframes.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,MAAM,EAAE,kBAAkB,EAAE,MAAM,eAAe,CAAC;AAG3D,OAAO,EAAE,MAAM,EAAE,MAAM,YAAY,CAAC;AACpC,OAAO,EAAE,yBAAyB,EAAE,MAAM,SAAS,CAAC;AAQpD;;;GAGG;AACH,MAAM,uBAAuB,GAAG,IAAI,CAAC;AAErC;;GAEG;AACH,MAAM,OAAO,2BAA2B;IAWtC,YAAmB,uBAAoD,EAAE,SAAwB;QAVjG,0EAA0E;QAClE,kBAAa,GAAkF,IAAI,GAAG,EAAE,CAAC;QACjH,sEAAsE;QAC9D,qBAAgB,GAA4B,IAAI,GAAG,EAAE,CAAC;QAQ5D,MAAM,CAAC,GAAG,CAAC,iEAAiE,CAAC,CAAC;QAE9E,uBAAuB,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;IACzE,CAAC;IAED;;;OAGG;IACI,kBAAkB,CAAC,WAAwB;QAChD,KAAK,MAAM,CAAC,iBAAiB,EAAE;aAC5B,IAAI,CAAC,aAAa,CAAC,EAAE;YACpB,IAAI,aAAa,EAAE;gBACjB,WAAW,CAAC,OAAO,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC;aACrD;QACH,CAAC,CAAC;aACD,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE;YACvB,MAAM,CAAC,KAAK,CAAC,4DAA4D,KAAK,EAAE,CAAC,CAAC;QACpF,CAAC,CAAC,CAAC;QAEL,yBAAyB,CAAC,WAAW,EAAE,CAAC,CAAO,EAAE,YAAqB,EAAE,EAAE;YACxE,IAAI,CAAC,YAAY,EAAE;gBACjB,IAAI,CAAC,aAAa,EAAE,CAAC;aACtB;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,mBAAmB,CAAC,WAAwB;QACjD,IAAI,CAAC,0BAA0B,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,MAAe,EAAE,EAAE;YAC/E,MAAM,CAAC,KAAK,CAAC,0DAA0D,EAAE,MAAM,CAAC,CAAC;QACnF,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACK,aAAa;QACnB,MAAM,SAAS,GAAG,kBAAkB,EAAE,CAAC;QAEvC,KAAK,MAAM,CAAC,iBAAiB,EAAE;aAC5B,IAAI,CAAC,YAAY,CAAC,EAAE;YACnB,IAAI,YAAY,EAAE;gBAChB,IAAI,CAAC,qBAAqB,GAAG;oBAC3B,SAAS;oBACT,YAAY;iBACb,CAAC;aACH;QACH,CAAC,CAAC;aACD,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE;YACvB,MAAM,CAAC,KAAK,CAAC,4DAA4D,KAAK,EAAE,CAAC,CAAC;QACpF,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACW,sBAAsB,CAClC,OAAe,EACf,iBAAyB,EACzB,WAAiC;;YAEjC,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;gBACnC,OAAO,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,iBAAiB,EAAE,WAAW,CAAC,CAAC;aAC3E;YAED,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC3B,MAAM,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;oBAC9B,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;oBAEtC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAChB,CAAC,EAAE,IAAI,CAAC,CAAC;gBAET,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE;oBACtC,OAAO,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,iBAAiB,EAAE,WAAW,CAAC,CAAC,CAAC;oBAE5E,YAAY,CAAC,OAAO,CAAC,CAAC;oBACtB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBACxC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;OAEG;IACK,oBAAoB,CAC1B,OAAe,EACf,iBAAyB,EAAE,sCAAsC;IACjE,WAAiC;QAEjC,IAAI,iBAAmD,CAAC;QAExD,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC/C,IACE,MAAM;YACN,MAAM,CAAC,YAAY;YACnB,2FAA2F;YAC3F,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,GAAG,iBAAiB,CAAC,GAAG,uBAAuB,EACxE;YACA,iBAAiB,GAAG,MAAM,CAAC,YAAY,CAAC;SACzC;aAAM,IACL,IAAI,CAAC,qBAAqB;YAC1B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,CAAC,SAAS,GAAG,iBAAiB,CAAC,GAAG,uBAAuB,EAC5F;YACA,uGAAuG;YACvG,uCAAuC;YACvC,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,YAAY,CAAC;SAC7D;aAAM;YACL,OAAO,IAAI,CAAC;SACb;QAED,MAAM,YAAY,GAAG;YACnB,YAAY,EAAE;gBACZ,KAAK,EAAE,iBAAiB,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW;gBAC9D,IAAI,EAAE,MAAM;aACb;YACD,aAAa,EAAE;gBACb,KAAK,EAAE,iBAAiB,CAAC,YAAY,GAAG,WAAW,CAAC,YAAY;gBAChE,IAAI,EAAE,MAAM;aACb;YACD,WAAW,EAAE;gBACX,KAAK,EAAE,iBAAiB,CAAC,UAAU,GAAG,WAAW,CAAC,UAAU;gBAC5D,IAAI,EAAE,MAAM;aACb;SACF,CAAC;QAEF,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;OAEG;IACW,0BAA0B,CAAC,WAAwB;;;YAC/D,MAAM,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,aAAiD,CAAC;YAEvF,mHAAmH;YACnH,MAAM,SAAS,GAAG,kBAAkB,EAAE,CAAC;YACvC,IAAI,YAAY,GAAgC,IAAI,CAAC;YACrD,IAAI,WAAW,EAAE;gBACf,YAAY,GAAG,MAAM,MAAM,CAAC,iBAAiB,EAAE,CAAC;aACjD;YAED,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,EAAE;gBAC1C,YAAY,EAAE,YAAY;gBAC1B,SAAS;aACV,CAAC,CAAC;YAEH,MAAA,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,2CAAI,CAAC;YAEnD,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC;;KAC/D;IAED;;OAEG;IACK,mBAAmB,CAAC,WAAwB;QAClD,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE;YAC/C,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAE/C,MAAM,CAAC,GAAG,CACR,8CAA8C,WAAW,CAAC,EAAE,gBAAgB,WAAW,CAAC,IAAI,0CAA0C,CACvI,CAAC;SACH;IACH,CAAC;IAED;;;OAGG;IACW,aAAa,CAAC,KAAY,EAAE,SAAwB;;;YAChE,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,OAAO,KAAK,CAAC;aACd;YAED,IAAI,KAAK,CAAC,IAAI,KAAK,aAAa,IAAI,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE;gBAC/F,MAAM,YAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,KAKnC,CAAC;gBAEF,MAAM,OAAO,GAAG,YAAY,CAAC,QAAQ,CAAC;gBAEtC,IAAI,OAAO,KAAI,MAAA,YAAY,CAAC,IAAI,0CAAE,aAAa,CAAA,IAAI,KAAK,CAAC,SAAS,EAAE;oBAClE,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,sBAAsB,CACpD,OAAO,EACP,KAAK,CAAC,SAAS,EACf,YAAY,CAAC,IAAI,CAAC,aAAqC,CACxD,CAAC;oBAEF,IAAI,CAAC,YAAY,EAAE;wBACjB,MAAM,CAAC,GAAG,CACR,oDAAoD,YAAY,CAAC,EAAE,gBAAgB,KAAK,CAAC,WAAW,0CAA0C,CAC/I,CAAC;qBACH;yBAAM;wBACL,MAAM,CAAC,GAAG,CACR,yCAAyC,YAAY,CAAC,EAAE,gBACtD,KAAK,CAAC,WACR,KAAK,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,EAAE,CAAC,CAAC,EAAE,CAClD,CAAC;wBAEF,KAAK,CAAC,YAAY,mCACb,CAAC,MAAA,KAAK,CAAC,YAAY,mCAAI,EAAE,CAAC,GAC1B,YAAY,CAChB,CAAC;wBAEF,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;qBACpC;oBAED,OAAO,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC;iBACxC;aACF;YAED,OAAO,KAAK,CAAC;;KACd;CACF","sourcesContent":["import type { Span, Transaction } from '@sentry/core';\nimport type { Event, EventProcessor, Measurements, MeasurementUnit } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport type { NativeFramesResponse } from '../NativeRNSentry';\nimport { NATIVE } from '../wrapper';\nimport { instrumentChildSpanFinish } from './utils';\n\nexport interface FramesMeasurements extends Measurements {\n  frames_total: { value: number; unit: MeasurementUnit };\n  frames_slow: { value: number; unit: MeasurementUnit };\n  frames_frozen: { value: number; unit: MeasurementUnit };\n}\n\n/**\n * A margin of error of 50ms is allowed for the async native bridge call.\n * Anything larger would reduce the accuracy of our frames measurements.\n */\nconst MARGIN_OF_ERROR_SECONDS = 0.05;\n\n/**\n * Instrumentation to add native slow/frozen frames measurements onto transactions.\n */\nexport class NativeFramesInstrumentation {\n  /** The native frames at the transaction finish time, keyed by traceId. */\n  private _finishFrames: Map<string, { timestamp: number; nativeFrames: NativeFramesResponse | null }> = new Map();\n  /** The listeners for each native frames response, keyed by traceId */\n  private _framesListeners: Map<string, () => void> = new Map();\n  /** The native frames at the finish time of the most recent span. */\n  private _lastSpanFinishFrames?: {\n    timestamp: number;\n    nativeFrames: NativeFramesResponse;\n  };\n\n  public constructor(addGlobalEventProcessor: (e: EventProcessor) => void, doesExist: () => boolean) {\n    logger.log('[ReactNativeTracing] Native frames instrumentation initialized.');\n\n    addGlobalEventProcessor(event => this._processEvent(event, doesExist));\n  }\n\n  /**\n   * To be called when a transaction is started.\n   * Logs the native frames at this start point and instruments child span finishes.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    void NATIVE.fetchNativeFrames()\n      .then(framesMetrics => {\n        if (framesMetrics) {\n          transaction.setData('__startFrames', framesMetrics);\n        }\n      })\n      .then(undefined, error => {\n        logger.error(`[ReactNativeTracing] Error while fetching native frames: ${error}`);\n      });\n\n    instrumentChildSpanFinish(transaction, (_: Span, endTimestamp?: number) => {\n      if (!endTimestamp) {\n        this._onSpanFinish();\n      }\n    });\n  }\n\n  /**\n   * To be called when a transaction is finished\n   */\n  public onTransactionFinish(transaction: Transaction): void {\n    this._fetchFramesForTransaction(transaction).then(undefined, (reason: unknown) => {\n      logger.error(`[ReactNativeTracing] Error while fetching native frames:`, reason);\n    });\n  }\n\n  /**\n   * Called on a span finish to fetch native frames to support transactions with trimEnd.\n   * Only to be called when a span does not have an end timestamp.\n   */\n  private _onSpanFinish(): void {\n    const timestamp = timestampInSeconds();\n\n    void NATIVE.fetchNativeFrames()\n      .then(nativeFrames => {\n        if (nativeFrames) {\n          this._lastSpanFinishFrames = {\n            timestamp,\n            nativeFrames,\n          };\n        }\n      })\n      .then(undefined, error => {\n        logger.error(`[ReactNativeTracing] Error while fetching native frames: ${error}`);\n      });\n  }\n\n  /**\n   * Returns the computed frames measurements and awaits for them if they are not ready yet.\n   */\n  private async _getFramesMeasurements(\n    traceId: string,\n    finalEndTimestamp: number,\n    startFrames: NativeFramesResponse,\n  ): Promise<FramesMeasurements | null> {\n    if (this._finishFrames.has(traceId)) {\n      return this._prepareMeasurements(traceId, finalEndTimestamp, startFrames);\n    }\n\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        this._framesListeners.delete(traceId);\n\n        resolve(null);\n      }, 2000);\n\n      this._framesListeners.set(traceId, () => {\n        resolve(this._prepareMeasurements(traceId, finalEndTimestamp, startFrames));\n\n        clearTimeout(timeout);\n        this._framesListeners.delete(traceId);\n      });\n    });\n  }\n\n  /**\n   * Returns the computed frames measurements given ready data\n   */\n  private _prepareMeasurements(\n    traceId: string,\n    finalEndTimestamp: number, // The actual transaction finish time.\n    startFrames: NativeFramesResponse,\n  ): FramesMeasurements | null {\n    let finalFinishFrames: NativeFramesResponse | undefined;\n\n    const finish = this._finishFrames.get(traceId);\n    if (\n      finish &&\n      finish.nativeFrames &&\n      // Must be in the margin of error of the actual transaction finish time (finalEndTimestamp)\n      Math.abs(finish.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS\n    ) {\n      finalFinishFrames = finish.nativeFrames;\n    } else if (\n      this._lastSpanFinishFrames &&\n      Math.abs(this._lastSpanFinishFrames.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS\n    ) {\n      // Fallback to the last span finish if it is within the margin of error of the actual finish timestamp.\n      // This should be the case for trimEnd.\n      finalFinishFrames = this._lastSpanFinishFrames.nativeFrames;\n    } else {\n      return null;\n    }\n\n    const measurements = {\n      frames_total: {\n        value: finalFinishFrames.totalFrames - startFrames.totalFrames,\n        unit: 'none',\n      },\n      frames_frozen: {\n        value: finalFinishFrames.frozenFrames - startFrames.frozenFrames,\n        unit: 'none',\n      },\n      frames_slow: {\n        value: finalFinishFrames.slowFrames - startFrames.slowFrames,\n        unit: 'none',\n      },\n    };\n\n    return measurements;\n  }\n\n  /**\n   * Fetch finish frames for a transaction at the current time. Calls any awaiting listeners.\n   */\n  private async _fetchFramesForTransaction(transaction: Transaction): Promise<void> {\n    const startFrames = transaction.data.__startFrames as NativeFramesResponse | undefined;\n\n    // This timestamp marks when the finish frames were retrieved. It should be pretty close to the transaction finish.\n    const timestamp = timestampInSeconds();\n    let finishFrames: NativeFramesResponse | null = null;\n    if (startFrames) {\n      finishFrames = await NATIVE.fetchNativeFrames();\n    }\n\n    this._finishFrames.set(transaction.traceId, {\n      nativeFrames: finishFrames,\n      timestamp,\n    });\n\n    this._framesListeners.get(transaction.traceId)?.();\n\n    setTimeout(() => this._cancelFinishFrames(transaction), 2000);\n  }\n\n  /**\n   * On a finish frames failure, we cancel the await.\n   */\n  private _cancelFinishFrames(transaction: Transaction): void {\n    if (this._finishFrames.has(transaction.traceId)) {\n      this._finishFrames.delete(transaction.traceId);\n\n      logger.log(\n        `[NativeFrames] Native frames timed out for ${transaction.op} transaction ${transaction.name}. Not adding native frames measurements.`,\n      );\n    }\n  }\n\n  /**\n   * Adds frames measurements to an event. Called from a valid event processor.\n   * Awaits for finish frames if needed.\n   */\n  private async _processEvent(event: Event, doesExist: () => boolean): Promise<Event> {\n    if (!doesExist()) {\n      return event;\n    }\n\n    if (event.type === 'transaction' && event.transaction && event.contexts && event.contexts.trace) {\n      const traceContext = event.contexts.trace as {\n        data?: { [key: string]: unknown };\n        trace_id: string;\n        name?: string;\n        op?: string;\n      };\n\n      const traceId = traceContext.trace_id;\n\n      if (traceId && traceContext.data?.__startFrames && event.timestamp) {\n        const measurements = await this._getFramesMeasurements(\n          traceId,\n          event.timestamp,\n          traceContext.data.__startFrames as NativeFramesResponse,\n        );\n\n        if (!measurements) {\n          logger.log(\n            `[NativeFrames] Could not fetch native frames for ${traceContext.op} transaction ${event.transaction}. Not adding native frames measurements.`,\n          );\n        } else {\n          logger.log(\n            `[Measurements] Adding measurements to ${traceContext.op} transaction ${\n              event.transaction\n            }: ${JSON.stringify(measurements, undefined, 2)}`,\n          );\n\n          event.measurements = {\n            ...(event.measurements ?? {}),\n            ...measurements,\n          };\n\n          this._finishFrames.delete(traceId);\n        }\n\n        delete traceContext.data.__startFrames;\n      }\n    }\n\n    return event;\n  }\n}\n"]}