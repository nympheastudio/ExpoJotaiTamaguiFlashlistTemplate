{"version":3,"sources":["toPattern.ts"],"names":["toPattern","value","optionPattern","pattern","patternChars","replace","output","split","values","toString","charsValues","placeholder","undefined","charCounter","index","outputLength","length","join","DIGIT","match","ALPHA","ALPHANUM","slice","substr"],"mappings":";;;;;;;AAAA;;AACA;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,CACEC,KADF,EAEEC,aAFF,EAGU;AACR,QAAMC,OAAO,GACX,OAAOD,aAAP,KAAyB,QAAzB,GAAoCA,aAAa,CAACC,OAAlD,GAA4DD,aAD9D;AAEA,QAAME,YAAY,GAAGD,OAAO,CAACE,OAAR,CAAgB,KAAhB,EAAuB,EAAvB,CAArB;AACA,QAAMC,MAAM,GAAGH,OAAO,CAACI,KAAR,CAAc,EAAd,CAAf;AACA,QAAMC,MAAM,GAAGP,KAAK,CAACQ,QAAN,GAAiBJ,OAAjB,CAAyB,KAAzB,EAAgC,EAAhC,CAAf;AACA,QAAMK,WAAW,GAAGF,MAAM,CAACH,OAAP,CAAe,KAAf,EAAsB,EAAtB,CAApB;AACA,QAAMM,WAAW,GACf,OAAOT,aAAP,KAAyB,QAAzB,GAAoCA,aAAa,CAACS,WAAlD,GAAgEC,SADlE;AAEA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,KAAJ;AAEA,QAAMC,YAAY,GAAGT,MAAM,CAACU,MAA5B;;AACA,OAAKF,KAAK,GAAG,CAAb,EAAgBA,KAAK,GAAGC,YAAxB,EAAsCD,KAAK,EAA3C,EAA+C;AAC7C;AACA,QAAID,WAAW,IAAIL,MAAM,CAACQ,MAA1B,EAAkC;AAChC,UAAIZ,YAAY,CAACY,MAAb,KAAwBN,WAAW,CAACM,MAAxC,EAAgD;AAC9C,eAAOV,MAAM,CAACW,IAAP,CAAY,EAAZ,CAAP;AACD;;AACD,UACEN,WAAW,KAAKC,SAAhB,IACAR,YAAY,CAACY,MAAb,GAAsBN,WAAW,CAACM,MAFpC,EAGE;AACA,eAAO,6BAAeV,MAAf,EAAuBQ,KAAvB,EAA8BH,WAA9B,EAA2CM,IAA3C,CAAgD,EAAhD,CAAP;AACD;;AACD;AACD,KAXD,MAWO,IACJX,MAAM,CAACQ,KAAD,CAAN,KAAkBI,gBAAlB,IAA2BV,MAAM,CAACK,WAAD,CAAN,CAAoBM,KAApB,CAA0B,OAA1B,CAA5B,IACCb,MAAM,CAACQ,KAAD,CAAN,KAAkBM,gBAAlB,IAA2BZ,MAAM,CAACK,WAAD,CAAN,CAAoBM,KAApB,CAA0B,UAA1B,CAD5B,IAECb,MAAM,CAACQ,KAAD,CAAN,KAAkBO,mBAAlB,IAA8Bb,MAAM,CAACK,WAAD,CAAN,CAAoBM,KAApB,CAA0B,aAA1B,CAH1B,EAIL;AACAb,MAAAA,MAAM,CAACQ,KAAD,CAAN,GAAgBN,MAAM,CAACK,WAAW,EAAZ,CAAtB;AACD,KANM,MAMA,IACLP,MAAM,CAACQ,KAAD,CAAN,KAAkBI,gBAAlB,IACAZ,MAAM,CAACQ,KAAD,CAAN,KAAkBM,gBADlB,IAEAd,MAAM,CAACQ,KAAD,CAAN,KAAkBO,mBAHb,EAIL;AACA,UAAIV,WAAW,KAAKC,SAApB,EAA+B;AAC7B,eAAO,6BAAeN,MAAf,EAAuBQ,KAAvB,EAA8BH,WAA9B,EAA2CM,IAA3C,CAAgD,EAAhD,CAAP;AACD;;AACD,aAAOX,MAAM,CAACgB,KAAP,CAAa,CAAb,EAAgBR,KAAhB,EAAuBG,IAAvB,CAA4B,EAA5B,CAAP,CAJA,CAMA;AACD,KAXM,MAWA,IAAIX,MAAM,CAACQ,KAAD,CAAN,KAAkBN,MAAM,CAACK,WAAD,CAA5B,EAA2C;AAChDA,MAAAA,WAAW;AACZ;AACF;;AACD,SAAOP,MAAM,CAACW,IAAP,CAAY,EAAZ,EAAgBM,MAAhB,CAAuB,CAAvB,EAA0BT,KAA1B,CAAP;AACD;;eAEcd,S","sourcesContent":["import { DIGIT, ALPHA, ALPHANUM } from './constants'\nimport addPlaceholder from './addPlaceholder'\n\ntype OptionPattern = {\n  pattern: string\n  placeholder: string\n}\n\n/**\n * function toPattern\n * @param {number | string} value\n * @param {string | OptionPattern} optionPattern\n * @returns {string}\n */\nfunction toPattern(\n  value: number | string,\n  optionPattern: string | OptionPattern\n): string {\n  const pattern =\n    typeof optionPattern === 'object' ? optionPattern.pattern : optionPattern\n  const patternChars = pattern.replace(/\\W/g, '')\n  const output = pattern.split('')\n  const values = value.toString().replace(/\\W/g, '')\n  const charsValues = values.replace(/\\W/g, '')\n  const placeholder =\n    typeof optionPattern === 'object' ? optionPattern.placeholder : undefined\n  let charCounter = 0\n  let index\n\n  const outputLength = output.length\n  for (index = 0; index < outputLength; index++) {\n    // Reached the end of input\n    if (charCounter >= values.length) {\n      if (patternChars.length === charsValues.length) {\n        return output.join('')\n      }\n      if (\n        placeholder !== undefined &&\n        patternChars.length > charsValues.length\n      ) {\n        return addPlaceholder(output, index, placeholder).join('')\n      }\n      break\n    } else if (\n      (output[index] === DIGIT && values[charCounter].match(/[0-9]/)) ||\n      (output[index] === ALPHA && values[charCounter].match(/[a-zA-Z]/)) ||\n      (output[index] === ALPHANUM && values[charCounter].match(/[0-9a-zA-Z]/))\n    ) {\n      output[index] = values[charCounter++]\n    } else if (\n      output[index] === DIGIT ||\n      output[index] === ALPHA ||\n      output[index] === ALPHANUM\n    ) {\n      if (placeholder !== undefined) {\n        return addPlaceholder(output, index, placeholder).join('')\n      }\n      return output.slice(0, index).join('')\n\n      // exact match for a non-magic character\n    } else if (output[index] === values[charCounter]) {\n      charCounter++\n    }\n  }\n  return output.join('').substr(0, index)\n}\n\nexport default toPattern\n"]}