"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BUFFER = "BUFFER",
    RAW = "RAW",
    VIEW = "VIEW";

var Writer = (function () {
  function Writer() {
    var cap = arguments.length <= 0 || arguments[0] === undefined ? 32 : arguments[0];

    _classCallCheck(this, Writer);

    this.index = 0;
    this.buffer = new ArrayBuffer(cap);
  }

  _createClass(Writer, [{
    key: "ensureSize",
    value: function ensureSize(n) {
      if (n < this.buffer.byteLength) return this;

      var nsize = n + 32;
      var view = new Uint8Array(nsize);
      view.set(this[RAW], 0);
      this.buffer = view.buffer;
      return this;
    }
  }, {
    key: "ensureFree",
    value: function ensureFree(n) {
      return this.ensureSize(this.index + n);
    }
  }, {
    key: "write",
    value: function write(arr) {
      if (!(arr instanceof Uint8Array)) {
        arr = new Uint8Array(arr);
      }

      this.ensureFree(arr.byteLength);
      this[RAW].set(arr, this.index);
      this.index += arr.byteLength;

      return this;
    }
  }, {
    key: "writeVarInt",
    value: function writeVarInt(num) {
      num = num << 1;
      if (num < 0) num = ~num;
      return this.writeUVarInt(num);
    }
  }, {
    key: "writeUVarInt",
    value: function writeUVarInt(num) {
      var bytes = [];
      while (num > 0x80) {
        bytes.push(num & 0xFF | 0x80);
        num = num >> 7;
      }
      bytes.push(num | 0);

      this.write(bytes);

      return this;
    }
  }, {
    key: "writeString",
    value: function writeString(string) {
      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var _ref$prefixed = _ref.prefixed;
      var prefixed = _ref$prefixed === undefined ? true : _ref$prefixed;

      var length = utf8ByteCount(string),
          out = new Uint8Array(length),
          offset = 0;

      if (prefixed) this.writeUVarInt(length);

      this.ensureFree(length);

      for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);

        // One byte of UTF-8
        if (codePoint < 0x80) {
          out[offset++] = codePoint >>> 0 & 0x7f | 0x00;
          continue;
        }

        // Two bytes of UTF-8
        if (codePoint < 0x800) {
          out[offset++] = codePoint >>> 6 & 0x1f | 0xc0;
          out[offset++] = codePoint >>> 0 & 0x3f | 0x80;
          continue;
        }

        // Three bytes of UTF-8.
        if (codePoint < 0x10000) {
          out[offset++] = codePoint >>> 12 & 0x0f | 0xe0;
          out[offset++] = codePoint >>> 6 & 0x3f | 0x80;
          out[offset++] = codePoint >>> 0 & 0x3f | 0x80;
          continue;
        }

        // Four bytes of UTF-8
        if (codePoint < 0x110000) {
          out[offset++] = codePoint >>> 18 & 0x07 | 0xf0;
          out[offset++] = codePoint >>> 12 & 0x3f | 0x80;
          out[offset++] = codePoint >>> 6 & 0x3f | 0x80;
          out[offset++] = codePoint >>> 0 & 0x3f | 0x80;
          continue;
        }
        throw new Error("bad codepoint " + codePoint);
      }

      this.write(out);
      return this;
    }
  }, {
    key: "buffer",
    set: function set(buffer) {
      this[BUFFER] = buffer;
      this[RAW] = new Uint8Array(this[BUFFER]);
      this[VIEW] = new DataView(this[BUFFER]);
      this.index = Math.min(this.buffer.byteLength, Math.max(0, this.index));
    },
    get: function get() {
      return this[BUFFER].slice(0, this.index);
    }
  }]);

  return Writer;
})();

exports["default"] = Writer;
;

[["Int8", 1], ["Uint8", 1], ["Int16", 2], ["Uint16", 2], ["Int32", 4], ["Uint32", 4], ["Float32", 4], ["Float64", 8]].forEach(function (_ref2) {
  var _ref22 = _slicedToArray(_ref2, 2);

  var name = _ref22[0];
  var len = _ref22[1];

  Writer.prototype["write" + name] = function (value) {
    this.ensureFree(len)[VIEW]["set" + name](this.index, value, false);
    this.index += len;
    return this;
  };
});

function utf8ByteCount(string) {
  var count = 0;
  for (var i = 0, l = string.length; i < l; i++) {
    var codePoint = string.charCodeAt(i);
    if (codePoint < 0x80) {
      count += 1;
      continue;
    }
    if (codePoint < 0x800) {
      count += 2;
      continue;
    }
    if (codePoint < 0x10000) {
      count += 3;
      continue;
    }
    if (codePoint < 0x110000) {
      count += 4;
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
  return count;
}
module.exports = exports["default"];