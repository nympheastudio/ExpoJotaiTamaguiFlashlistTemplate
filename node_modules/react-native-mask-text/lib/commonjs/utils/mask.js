"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mask = mask;
exports.unMask = unMask;

var _bignumber = require("bignumber.js");

var _toPattern = _interopRequireDefault(require("./toPattern"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-confusing-arrow */

/**
 * function unMask(
 * @param {string} value
 * @param {'custom' | 'currency'} type
 * @returns {string}
 */
function unMask(value) {
  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom';

  if (type === 'currency') {
    if (!value) return '0';
    const unMaskedValue = value.replace(/\D/g, '');
    const number = parseInt(unMaskedValue.trimStart());
    return number.toString();
  }

  return value.replace(/\W/g, '');
}
/**
 * function masker(
 * @param {string} value
 * @param {string} patterns
 * @param {any} options
 * @returns {string}
 */


function masker(value, pattern, options) {
  return (0, _toPattern.default)(value, {
    pattern,
    ...options
  });
}
/**
 * function masker(
 * @param {string} value
 * @param {any} options
 * @returns {string}
 */


function currencyMasker() {
  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
  let options = arguments.length > 1 ? arguments[1] : undefined;
  const {
    prefix,
    decimalSeparator,
    groupSeparator,
    precision,
    groupSize,
    secondaryGroupSize,
    fractionGroupSeparator,
    fractionGroupSize,
    suffix
  } = options;
  const precisionDivider = parseInt(1 + '0'.repeat(precision || 0));
  const number = parseInt(value) / precisionDivider;
  const formatter = {
    prefix,
    decimalSeparator,
    groupSeparator,
    groupSize: groupSize || 3,
    secondaryGroupSize,
    fractionGroupSeparator,
    fractionGroupSize,
    suffix
  };
  const bigNumber = new _bignumber.BigNumber(number);

  _bignumber.BigNumber.config({
    FORMAT: formatter
  });

  return bigNumber.toFormat(precision);
}
/**
 * function multimasker(
 * @param {string} value
 * @param {string[]} patterns
 * @param {any} options
 * @returns {string}
 */


function multimasker(value, patterns, options) {
  return masker(value, patterns.reduce((memo, pattern) => value.length <= unMask(memo).length ? memo : pattern, patterns[0]), options);
}
/**
 * function mask(
 * @param {string} value
 * @param {string | string[]} patterns
 * @param {'custom' | 'currency'} type
 * @param {any} options
 * @returns {string}
 */


function mask(value) {
  let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'custom';
  let options = arguments.length > 3 ? arguments[3] : undefined;

  if (type === 'currency') {
    return currencyMasker(String(value), options);
  }

  if (typeof pattern === 'string') {
    return masker(String(value), pattern || '', {});
  }

  return multimasker(String(value), pattern, {});
}
//# sourceMappingURL=mask.js.map