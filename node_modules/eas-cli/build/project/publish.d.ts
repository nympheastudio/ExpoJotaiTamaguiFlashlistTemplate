/// <reference types="node" />
import { ExpoConfig, Platform } from '@expo/config';
import { Env, Workflow } from '@expo/eas-build-job';
import Joi from 'joi';
import { ExpoGraphqlClient } from '../commandUtils/context/contextUtils/createGraphqlClient';
import { PaginatedQueryOptions } from '../commandUtils/pagination';
import { PartialManifestAsset } from '../graphql/generated';
import { RequestedPlatform } from '../platform';
import { Client } from '../vcs/vcs';
export type ExpoCLIExportPlatformFlag = Platform | 'all';
type Metadata = {
    version: number;
    bundler: 'metro';
    fileMetadata: {
        [key in Platform]: {
            assets: {
                path: string;
                ext: string;
            }[];
            bundle: string;
        };
    };
};
export type RawAsset = {
    fileExtension?: string;
    contentType: string;
    path: string;
    /** Original asset path derrived from asset map, or exported folder */
    originalPath?: string;
};
type CollectedAssets = {
    [platform in Platform]?: {
        launchAsset: RawAsset;
        assets: RawAsset[];
    };
};
type ManifestExtra = {
    expoClient?: {
        [key: string]: any;
    };
    [key: string]: any;
};
type ManifestFragment = {
    launchAsset: PartialManifestAsset;
    assets: PartialManifestAsset[];
    extra?: ManifestExtra;
};
type UpdateInfoGroup = {
    [key in Platform]: ManifestFragment;
};
type AssetMap = Record<string, {
    httpServerLocation: string;
    name: string;
    type: string;
}>;
export declare const MetadataJoi: Joi.ObjectSchema<any>;
export declare function guessContentTypeFromExtension(ext?: string): string;
export declare function getBase64URLEncoding(buffer: Buffer): string;
/**
 * The storage key is used to store the asset in GCS
 */
export declare function getStorageKey(contentType: string, contentHash: string): string;
/**
 * Convenience function that computes an assets storage key starting from its buffer.
 */
export declare function getStorageKeyForAssetAsync(asset: RawAsset): Promise<string>;
export declare function convertAssetToUpdateInfoGroupFormatAsync(asset: RawAsset): Promise<PartialManifestAsset>;
/**
 * This will be sorted later based on the platform's runtime versions.
 */
export declare function buildUnsortedUpdateInfoGroupAsync(assets: CollectedAssets, exp: ExpoConfig): Promise<UpdateInfoGroup>;
export declare function buildBundlesAsync({ projectDir, inputDir, exp, platformFlag, clearCache, }: {
    projectDir: string;
    inputDir: string;
    exp: Pick<ExpoConfig, 'sdkVersion' | 'web'>;
    platformFlag: ExpoCLIExportPlatformFlag;
    clearCache?: boolean;
}): Promise<void>;
export declare function resolveInputDirectoryAsync(inputDir: string, { skipBundler }: {
    skipBundler?: boolean;
}): Promise<string>;
export declare function loadMetadata(distRoot: string): Metadata;
export declare function filterExportedPlatformsByFlag<T extends Partial<Record<Platform, any>>>(record: T, platformFlag: ExpoCLIExportPlatformFlag): T;
/** Try to load the asset map for logging the names of assets published */
export declare function loadAssetMapAsync(distRoot: string): Promise<AssetMap | null>;
export declare function getAssetHashFromPath(assetPath: string): string | null;
export declare function getOriginalPathFromAssetMap(assetMap: AssetMap | null, asset: {
    path: string;
    ext: string;
}): string | null;
/** Given a directory, load the metadata.json and collect the assets for each platform. */
export declare function collectAssetsAsync(dir: string): Promise<CollectedAssets>;
export declare function filterOutAssetsThatAlreadyExistAsync(graphqlClient: ExpoGraphqlClient, uniqueAssetsWithStorageKey: (RawAsset & {
    storageKey: string;
})[]): Promise<(RawAsset & {
    storageKey: string;
})[]>;
type AssetUploadResult = {
    /** All found assets within the exported folder per platform */
    assetCount: number;
    /** The uploaded JS bundles, per platform */
    launchAssetCount: number;
    /** All unique assets within the exported folder with platforms combined */
    uniqueAssetCount: number;
    /** All unique assets uploaded  */
    uniqueUploadedAssetCount: number;
    /** All (non-launch) asset original paths, used for logging */
    uniqueUploadedAssetPaths: string[];
    /** The asset limit received from the server */
    assetLimitPerUpdateGroup: number;
};
export declare function uploadAssetsAsync(graphqlClient: ExpoGraphqlClient, assetsForUpdateInfoGroup: CollectedAssets, projectId: string, cancelationToken: {
    isCanceledOrFinished: boolean;
}, onAssetUploadResultsChanged: (assetUploadResults: {
    asset: RawAsset & {
        storageKey: string;
    };
    finished: boolean;
}[]) => void, onAssetUploadBegin: () => void): Promise<AssetUploadResult>;
export declare function isUploadedAssetCountAboveWarningThreshold(uploadedAssetCount: number, assetLimitPerUpdateGroup: number): boolean;
export declare function getBranchNameForCommandAsync({ graphqlClient, projectId, channelNameArg, branchNameArg, autoFlag, nonInteractive, paginatedQueryOptions, vcsClient, }: {
    graphqlClient: ExpoGraphqlClient;
    projectId: string;
    channelNameArg: string | undefined;
    branchNameArg: string | undefined;
    autoFlag: boolean;
    nonInteractive: boolean;
    paginatedQueryOptions: PaginatedQueryOptions;
    vcsClient: Client;
}): Promise<string>;
export declare function getUpdateMessageForCommandAsync(vcsClient: Client, { updateMessageArg, autoFlag, nonInteractive, jsonFlag, }: {
    updateMessageArg: string | undefined;
    autoFlag: boolean;
    nonInteractive: boolean;
    jsonFlag: boolean;
}): Promise<string | undefined>;
export declare const defaultPublishPlatforms: Platform[];
export declare function getRequestedPlatform(platform: ExpoCLIExportPlatformFlag): RequestedPlatform | null;
/** Get runtime versions grouped by platform. Runtime version is always `null` on web where the platform is always backwards compatible. */
export declare function getRuntimeVersionObjectAsync({ exp, platforms, workflows, projectDir, env, }: {
    exp: ExpoConfig;
    platforms: Platform[];
    workflows: Record<Platform, Workflow>;
    projectDir: string;
    env: Env | undefined;
}): Promise<{
    platform: string;
    runtimeVersion: string;
}[]>;
export declare function getRuntimeToPlatformMappingFromRuntimeVersions(runtimeVersions: {
    platform: string;
    runtimeVersion: string;
}[]): {
    runtimeVersion: string;
    platforms: string[];
}[];
export declare const platformDisplayNames: Record<Platform, string>;
export {};
