import { exceptionFromError } from '@sentry/browser';
import { isInstanceOf, isPlainObject } from '@sentry/utils';
import { NATIVE } from '../wrapper';
const DEFAULT_KEY = 'cause';
const DEFAULT_LIMIT = 5;
/**
 * Processes JS and RN native linked errors.
 */
export class NativeLinkedErrors {
    /**
     * @inheritDoc
     */
    constructor(options = {}) {
        /**
         * @inheritDoc
         */
        this.name = NativeLinkedErrors.id;
        this._nativePackage = null;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
    }
    /**
     * @inheritDoc
     */
    setupOnce(_addGlobalEventProcessor, _getCurrentHub) {
        /* noop */
    }
    /**
     * @inheritDoc
     */
    preprocessEvent(event, hint, client) {
        if (this._nativePackage === null) {
            this._nativePackage = this._fetchNativePackage();
        }
        this._handler(client.getOptions().stackParser, this._key, this._limit, event, hint);
    }
    /**
     * Enriches passed event with linked exceptions and native debug meta images.
     */
    _handler(parser, key, limit, event, hint) {
        if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
            return;
        }
        const { exceptions: linkedErrors, debugImages } = this._walkErrorTree(parser, limit, hint.originalException, key);
        event.exception.values = [...event.exception.values, ...linkedErrors];
        event.debug_meta = event.debug_meta || {};
        event.debug_meta.images = event.debug_meta.images || [];
        event.debug_meta.images.push(...(debugImages || []));
    }
    /**
     * Walks linked errors and created Sentry exceptions chain.
     * Collects debug images from native errors stack frames.
     */
    _walkErrorTree(parser, limit, error, key, exceptions = [], debugImages = []) {
        const linkedError = error[key];
        if (!linkedError || exceptions.length + 1 >= limit) {
            return {
                exceptions,
                debugImages,
            };
        }
        let exception;
        let exceptionDebugImages;
        if ('stackElements' in linkedError) {
            // isJavaException
            exception = this._exceptionFromJavaStackElements(linkedError);
        }
        else if ('stackReturnAddresses' in linkedError) {
            // isObjCException
            const { appleException, appleDebugImages } = this._exceptionFromAppleStackReturnAddresses(linkedError);
            exception = appleException;
            exceptionDebugImages = appleDebugImages;
        }
        else if (isInstanceOf(linkedError, Error)) {
            exception = exceptionFromError(parser, error[key]);
        }
        else if (isPlainObject(linkedError)) {
            exception = {
                type: typeof linkedError.name === 'string' ? linkedError.name : undefined,
                value: typeof linkedError.message === 'string' ? linkedError.message : undefined,
            };
        }
        else {
            return {
                exceptions,
                debugImages,
            };
        }
        return this._walkErrorTree(parser, limit, linkedError, key, [...exceptions, exception], [...debugImages, ...(exceptionDebugImages || [])]);
    }
    /**
     * Converts a Java Throwable to an SentryException
     */
    _exceptionFromJavaStackElements(javaThrowable) {
        return {
            type: javaThrowable.name,
            value: javaThrowable.message,
            stacktrace: {
                frames: javaThrowable.stackElements
                    .map(stackElement => ({
                    platform: 'java',
                    module: stackElement.className,
                    filename: stackElement.fileName,
                    lineno: stackElement.lineNumber >= 0 ? stackElement.lineNumber : undefined,
                    function: stackElement.methodName,
                    in_app: this._nativePackage !== null && stackElement.className.startsWith(this._nativePackage)
                        ? true
                        : undefined,
                }))
                    .reverse(),
            },
        };
    }
    /**
     * Converts StackAddresses to a SentryException with DebugMetaImages
     */
    _exceptionFromAppleStackReturnAddresses(objCException) {
        const nativeStackFrames = this._fetchNativeStackFrames(objCException.stackReturnAddresses);
        return {
            appleException: {
                type: objCException.name,
                value: objCException.message,
                stacktrace: {
                    frames: (nativeStackFrames && nativeStackFrames.frames.reverse()) || [],
                },
            },
            appleDebugImages: (nativeStackFrames && nativeStackFrames.debugMetaImages) || [],
        };
    }
    /**
     * Fetches the native package/image name from the native layer
     */
    _fetchNativePackage() {
        return NATIVE.fetchNativePackageName();
    }
    /**
     * Fetches native debug image information on iOS
     */
    _fetchNativeStackFrames(instructionsAddr) {
        return NATIVE.fetchNativeStackFramesBy(instructionsAddr);
    }
}
/**
 * @inheritDoc
 */
NativeLinkedErrors.id = 'NativeLinkedErrors';
//# sourceMappingURL=nativelinkederrors.js.map