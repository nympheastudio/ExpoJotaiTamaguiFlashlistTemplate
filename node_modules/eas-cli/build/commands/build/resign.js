"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const _1 = require(".");
const build_1 = require("../../build/build");
const credentials_1 = require("../../build/ios/credentials");
const prepareJob_1 = require("../../build/ios/prepareJob");
const queries_1 = require("../../build/queries");
const printBuildInfo_1 = require("../../build/utils/printBuildInfo");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const context_1 = require("../../credentials/context");
const generated_1 = require("../../graphql/generated");
const BuildMutation_1 = require("../../graphql/mutations/BuildMutation");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const AppPlatform_1 = require("../../graphql/types/AppPlatform");
const log_1 = tslib_1.__importDefault(require("../../log"));
const platform_1 = require("../../platform");
const scheme_1 = require("../../project/ios/scheme");
const target_1 = require("../../project/ios/target");
const projectUtils_1 = require("../../project/projectUtils");
const json_1 = require("../../utils/json");
const statuspageService_1 = require("../../utils/statuspageService");
class BuildResign extends EasCommand_1.default {
    async runAsync() {
        const { flags: rawFlags } = await this.parse(_a);
        if (rawFlags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const flags = this.sanitizeFlags(rawFlags);
        const { limit, offset, nonInteractive } = flags;
        const { loggedIn: { actor, graphqlClient }, getDynamicPrivateProjectConfigAsync, projectDir, analytics, vcsClient, } = await this.getContextAsync(_a, {
            nonInteractive: flags.nonInteractive,
        });
        const maybeBuild = flags.maybeBuildId
            ? await this.maybeGetBuildAsync(graphqlClient, flags.maybeBuildId)
            : undefined;
        const platform = maybeBuild?.platform.toLowerCase() ??
            (await (0, platform_1.selectPlatformAsync)(flags.platform));
        if (platform === eas_build_job_1.Platform.ANDROID) {
            throw new Error('Re-signing archives is not supported on Android yet.');
        }
        await (0, _1.handleDeprecatedEasJsonAsync)(projectDir, flags.nonInteractive);
        await (0, statuspageService_1.maybeWarnAboutEasOutagesAsync)(graphqlClient, [generated_1.StatuspageServiceName.EasBuild]);
        const easJsonAccessor = eas_json_1.EasJsonAccessor.fromProjectPath(projectDir);
        const easJsonCliConfig = (await eas_json_1.EasJsonUtils.getCliConfigAsync(easJsonAccessor)) ?? {};
        const buildProfile = await eas_json_1.EasJsonUtils.getBuildProfileAsync(easJsonAccessor, platform, flags.profile ?? 'production');
        const { exp, projectId } = await getDynamicPrivateProjectConfigAsync({ env: buildProfile.env });
        const account = await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId);
        const build = await this.ensureBuildSelectedAsync({ graphqlClient, projectId, platform, nonInteractive, limit, offset }, maybeBuild);
        const credentialsCtx = new context_1.CredentialsContext({
            projectInfo: { exp, projectId },
            nonInteractive,
            projectDir,
            user: actor,
            graphqlClient,
            analytics,
            env: buildProfile.env,
            easJsonCliConfig,
            vcsClient,
        });
        if (buildProfile.credentialsSource !== eas_json_1.CredentialsSource.LOCAL && !nonInteractive) {
            await credentialsCtx.appStore.ensureAuthenticatedAsync();
        }
        const xcodeBuildContext = await (0, scheme_1.resolveXcodeBuildContextAsync)({
            projectDir,
            nonInteractive,
            exp,
            vcsClient,
        }, buildProfile);
        const targets = await (0, target_1.resolveTargetsAsync)({
            projectDir,
            exp,
            xcodeBuildContext,
            env: buildProfile.env,
            vcsClient,
        });
        const credentialsResult = await (0, credentials_1.ensureIosCredentialsForBuildResignAsync)(credentialsCtx, targets, buildProfile);
        (0, assert_1.default)(build.artifacts?.applicationArchiveUrl, 'Missing application archive.');
        const jobOverrides = {
            mode: generated_1.BuildMode.Resign,
            type: generated_1.BuildWorkflow.Unknown,
            resign: {
                applicationArchiveSource: {
                    type: generated_1.ProjectArchiveSourceType.Url,
                    url: build.artifacts?.applicationArchiveUrl,
                },
            },
            secrets: (0, prepareJob_1.prepareCredentialsToResign)(credentialsResult.credentials),
            builderEnvironment: { image: 'default' },
        };
        const newBuild = await BuildMutation_1.BuildMutation.retryIosBuildAsync(graphqlClient, {
            buildId: build.id,
            jobOverrides,
        });
        log_1.default.addNewLineIfNone();
        (0, printBuildInfo_1.printLogsUrls)([newBuild]);
        log_1.default.newLine();
        if (!flags.wait) {
            if (flags.json) {
                (0, json_1.printJsonOnlyOutput)(newBuild);
            }
            return;
        }
        const buildResult = await (0, build_1.waitForBuildEndAsync)(graphqlClient, {
            buildIds: [newBuild.id],
            accountName: account.name,
        });
        if (!flags.json) {
            (0, printBuildInfo_1.printBuildResults)(buildResult);
        }
        else {
            (0, assert_1.default)(buildResult[0], 'missing build results');
            (0, json_1.printJsonOnlyOutput)(buildResult[0]);
        }
    }
    sanitizeFlags(flags) {
        const nonInteractive = flags['non-interactive'];
        if (nonInteractive && !flags.id) {
            throw new Error(`${chalk_1.default.bold('--id')} is required when running with ${chalk_1.default.bold('--non-interactive')} flag.`);
        }
        return {
            json: flags.json,
            nonInteractive,
            offset: flags.offset,
            limit: flags.limit,
            platform: flags.platform,
            profile: flags.profile,
            maybeBuildId: flags.id,
            wait: flags.wait,
        };
    }
    async ensureBuildSelectedAsync({ graphqlClient, projectId, platform, nonInteractive, limit, offset, }, maybeBuild) {
        if (maybeBuild) {
            return maybeBuild;
        }
        const build = await (0, queries_1.listAndSelectBuildOnAppAsync)(graphqlClient, {
            projectId,
            title: 'Which build would you like to re-sign with new credentials?',
            paginatedQueryOptions: {
                limit,
                offset: offset ?? 0,
                nonInteractive,
                json: false,
            },
            filter: {
                distribution: generated_1.DistributionType.Internal,
                platform: (0, AppPlatform_1.toAppPlatform)(platform),
                status: generated_1.BuildStatus.Finished,
            },
        });
        if (!build) {
            throw new Error('There are no builds that can be re-signed on this project.');
        }
        return build;
    }
    async maybeGetBuildAsync(graphqlClient, maybeBuildId, maybePlatform) {
        if (maybeBuildId) {
            const build = await BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, maybeBuildId);
            if (build.distribution !== generated_1.DistributionType.Internal) {
                throw new Error('This is not an internal distribution build.');
            }
            if (build.status !== generated_1.BuildStatus.Finished) {
                throw new Error('Only builds that finished successfully can be re-signed.');
            }
            if (maybePlatform && build.platform !== (0, AppPlatform_1.toAppPlatform)(maybePlatform)) {
                throw new Error(`Build with ID ${maybeBuildId} was not created for platform ${platform_1.requestedPlatformDisplayNames[maybePlatform]}.`);
            }
            return build;
        }
        return undefined;
    }
}
_a = BuildResign;
BuildResign.description = 're-sign a build archive';
BuildResign.flags = {
    platform: core_1.Flags.enum({
        char: 'p',
        options: ['android', 'ios'],
    }),
    profile: core_1.Flags.string({
        char: 'e',
        description: 'Name of the build profile from eas.json. Defaults to "production" if defined in eas.json.',
        helpValue: 'PROFILE_NAME',
    }),
    wait: core_1.Flags.boolean({
        default: true,
        allowNo: true,
        description: 'Wait for build(s) to complete.',
    }),
    id: core_1.Flags.string({
        description: 'ID of the build to re-sign.',
    }),
    ...pagination_1.EasPaginatedQueryFlags,
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
BuildResign.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.ProjectDir,
    ..._a.ContextOptions.Analytics,
    ..._a.ContextOptions.Vcs,
};
exports.default = BuildResign;
