import { __awaiter } from "tslib";
import { addContextToFrame, logger } from '@sentry/utils';
import { getFramesToPop, isErrorLike } from '../utils/error';
import { ReactNativeLibraries } from '../utils/rnlibraries';
import { createStealthXhr, XHR_READYSTATE_DONE } from '../utils/xhr';
// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor
const INTERNAL_CALLSITES_REGEX = new RegExp(['ReactNativeRenderer-dev\\.js$', 'MessageQueue\\.js$'].join('|'));
/** Tries to symbolicate the JS stack trace on the device. */
export class DebugSymbolicator {
    constructor() {
        /**
         * @inheritDoc
         */
        this.name = DebugSymbolicator.id;
    }
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor((event, hint) => __awaiter(this, void 0, void 0, function* () {
            const self = getCurrentHub().getIntegration(DebugSymbolicator);
            if (!self) {
                return event;
            }
            if (event.exception && isErrorLike(hint.originalException)) {
                // originalException is ErrorLike object
                const symbolicatedFrames = yield this._symbolicate(hint.originalException.stack, getFramesToPop(hint.originalException));
                symbolicatedFrames && this._replaceExceptionFramesInEvent(event, symbolicatedFrames);
            }
            else if (hint.syntheticException && isErrorLike(hint.syntheticException)) {
                // syntheticException is Error object
                const symbolicatedFrames = yield this._symbolicate(hint.syntheticException.stack, getFramesToPop(hint.syntheticException));
                if (event.exception) {
                    symbolicatedFrames && this._replaceExceptionFramesInEvent(event, symbolicatedFrames);
                }
                else if (event.threads) {
                    // RN JS doesn't have threads
                    // syntheticException is used for Sentry.captureMessage() threads
                    symbolicatedFrames && this._replaceThreadFramesInEvent(event, symbolicatedFrames);
                }
            }
            return event;
        }));
    }
    /**
     * Symbolicates the stack on the device talking to local dev server.
     * Mutates the passed event.
     */
    _symbolicate(rawStack, skipFirstFrames = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const parsedStack = this._parseErrorStack(rawStack);
                const prettyStack = yield this._symbolicateStackTrace(parsedStack);
                if (!prettyStack) {
                    logger.error('React Native DevServer could not symbolicate the stack trace.');
                    return null;
                }
                // This has been changed in an react-native version so stack is contained in here
                const newStack = prettyStack.stack || prettyStack;
                // https://github.com/getsentry/sentry-javascript/blob/739d904342aaf9327312f409952f14ceff4ae1ab/packages/utils/src/stacktrace.ts#L23
                // Match SentryParser which counts lines of stack (-1 for first line with the Error message)
                const skipFirstAdjustedToSentryStackParser = Math.max(skipFirstFrames - 1, 0);
                const stackWithoutPoppedFrames = skipFirstAdjustedToSentryStackParser
                    ? newStack.slice(skipFirstAdjustedToSentryStackParser)
                    : newStack;
                const stackWithoutInternalCallsites = stackWithoutPoppedFrames.filter((frame) => frame.file && frame.file.match(INTERNAL_CALLSITES_REGEX) === null);
                return yield this._convertReactNativeFramesToSentryFrames(stackWithoutInternalCallsites);
            }
            catch (error) {
                if (error instanceof Error) {
                    logger.warn(`Unable to symbolicate stack trace: ${error.message}`);
                }
                return null;
            }
        });
    }
    /**
     * Converts ReactNativeFrames to frames in the Sentry format
     * @param frames ReactNativeFrame[]
     */
    _convertReactNativeFramesToSentryFrames(frames) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(frames.map((frame) => __awaiter(this, void 0, void 0, function* () {
                let inApp = !!frame.column && !!frame.lineNumber;
                inApp =
                    inApp &&
                        frame.file !== undefined &&
                        !frame.file.includes('node_modules') &&
                        !frame.file.includes('native code');
                const newFrame = {
                    lineno: frame.lineNumber,
                    colno: frame.column,
                    filename: frame.file,
                    function: frame.methodName,
                    in_app: inApp,
                };
                if (inApp) {
                    yield this._addSourceContext(newFrame);
                }
                return newFrame;
            })));
        });
    }
    /**
     * Replaces the frames in the exception of a error.
     * @param event Event
     * @param frames StackFrame[]
     */
    _replaceExceptionFramesInEvent(event, frames) {
        if (event.exception &&
            event.exception.values &&
            event.exception.values[0] &&
            event.exception.values[0].stacktrace) {
            event.exception.values[0].stacktrace.frames = frames.reverse();
        }
    }
    /**
     * Replaces the frames in the thread of a message.
     * @param event Event
     * @param frames StackFrame[]
     */
    _replaceThreadFramesInEvent(event, frames) {
        if (event.threads && event.threads.values && event.threads.values[0] && event.threads.values[0].stacktrace) {
            event.threads.values[0].stacktrace.frames = frames.reverse();
        }
    }
    /**
     * This tries to add source context for in_app Frames
     *
     * @param frame StackFrame
     * @param getDevServer function from RN to get DevServer URL
     */
    _addSourceContext(frame) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let sourceContext = null;
            const segments = (_b = (_a = frame.filename) === null || _a === void 0 ? void 0 : _a.split('/')) !== null && _b !== void 0 ? _b : [];
            const serverUrl = (_c = this._getDevServer()) === null || _c === void 0 ? void 0 : _c.url;
            if (!serverUrl) {
                return;
            }
            for (const idx in segments) {
                if (!Object.prototype.hasOwnProperty.call(segments, idx)) {
                    continue;
                }
                sourceContext = yield this._fetchSourceContext(serverUrl, segments, -idx);
                if (sourceContext) {
                    break;
                }
            }
            if (!sourceContext) {
                return;
            }
            const lines = sourceContext.split('\n');
            addContextToFrame(lines, frame);
        });
    }
    /**
     * Get source context for segment
     */
    _fetchSourceContext(url, segments, start) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                const fullUrl = `${url}${segments.slice(start).join('/')}`;
                const xhr = createStealthXhr();
                if (!xhr) {
                    resolve(null);
                    return;
                }
                xhr.open('GET', fullUrl, true);
                xhr.send();
                xhr.onreadystatechange = () => {
                    if (xhr.readyState === XHR_READYSTATE_DONE) {
                        if (xhr.status !== 200) {
                            resolve(null);
                        }
                        const response = xhr.responseText;
                        if (typeof response !== 'string' ||
                            // Expo Dev Server responses with status 200 and config JSON
                            // when web support not enabled and requested file not found
                            response.startsWith('{')) {
                            resolve(null);
                        }
                        resolve(response);
                    }
                };
                xhr.onerror = () => {
                    resolve(null);
                };
            });
        });
    }
    /**
     * Loads and calls RN Core Devtools parseErrorStack function.
     */
    _parseErrorStack(errorStack) {
        if (!ReactNativeLibraries.Devtools) {
            throw new Error('React Native Devtools not available.');
        }
        return ReactNativeLibraries.Devtools.parseErrorStack(errorStack);
    }
    /**
     * Loads and calls RN Core Devtools symbolicateStackTrace function.
     */
    _symbolicateStackTrace(stack, extraData) {
        if (!ReactNativeLibraries.Devtools) {
            throw new Error('React Native Devtools not available.');
        }
        return ReactNativeLibraries.Devtools.symbolicateStackTrace(stack, extraData);
    }
    /**
     * Loads and returns the RN DevServer URL.
     */
    _getDevServer() {
        var _a;
        try {
            return (_a = ReactNativeLibraries.Devtools) === null || _a === void 0 ? void 0 : _a.getDevServer();
        }
        catch (_oO) {
            // We can't load devserver URL
        }
        return undefined;
    }
}
/**
 * @inheritDoc
 */
DebugSymbolicator.id = 'DebugSymbolicator';
//# sourceMappingURL=debugsymbolicator.js.map