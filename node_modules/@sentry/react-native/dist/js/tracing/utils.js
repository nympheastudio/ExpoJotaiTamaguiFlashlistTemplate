import { setMeasurement, spanToJSON, } from '@sentry/core';
import { timestampInSeconds } from '@sentry/utils';
export const defaultTransactionSource = 'component';
export const customTransactionSource = 'custom';
export const getBlankTransactionContext = (name) => {
    return {
        name: 'Route Change',
        op: 'navigation',
        tags: {
            'routing.instrumentation': name,
        },
        data: {},
        metadata: {
            source: defaultTransactionSource,
        },
    };
};
/**
 * A margin of error of 50ms is allowed for the async native bridge call.
 * Anything larger would reduce the accuracy of our frames measurements.
 */
export const MARGIN_OF_ERROR_SECONDS = 0.05;
const timeOriginMilliseconds = Date.now();
/**
 *
 */
export function adjustTransactionDuration(maxDurationMs, transaction, endTimestamp) {
    const diff = endTimestamp - transaction.startTimestamp;
    const isOutdatedTransaction = endTimestamp && (diff > maxDurationMs || diff < 0);
    if (isOutdatedTransaction) {
        transaction.setStatus('deadline_exceeded');
        transaction.setTag('maxTransactionDurationExceeded', 'true');
    }
}
/**
 * Returns the timestamp where the JS global scope was initialized.
 */
export function getTimeOriginMilliseconds() {
    return timeOriginMilliseconds;
}
/**
 * Calls the callback every time a child span of the transaction is finished.
 */
export function instrumentChildSpanFinish(transaction, callback) {
    if (transaction.spanRecorder) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const originalAdd = transaction.spanRecorder.add;
        transaction.spanRecorder.add = (span) => {
            originalAdd.apply(transaction.spanRecorder, [span]);
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const originalSpanFinish = span.finish;
            span.finish = (endTimestamp) => {
                originalSpanFinish.apply(span, [endTimestamp]);
                callback(span, endTimestamp);
            };
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const originalSpanEnd = span.end;
            span.end = (endTimestamp) => {
                originalSpanEnd.apply(span, [endTimestamp]);
                callback(span, endTimestamp);
            };
        };
    }
}
/**
 * Determines if the timestamp is now or within the specified margin of error from now.
 */
export function isNearToNow(timestamp) {
    return Math.abs(timestampInSeconds() - timestamp) <= MARGIN_OF_ERROR_SECONDS;
}
/**
 * Sets the duration of the span as a measurement.
 * Uses `setMeasurement` function from @sentry/core.
 */
export function setSpanDurationAsMeasurement(name, span) {
    const spanEnd = spanToJSON(span).timestamp;
    const spanStart = spanToJSON(span).start_timestamp;
    if (!spanEnd || !spanStart) {
        return;
    }
    setMeasurement(name, (spanEnd - spanStart) * 1000, 'millisecond');
}
//# sourceMappingURL=utils.js.map