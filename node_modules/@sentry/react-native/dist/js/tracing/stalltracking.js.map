{"version":3,"file":"stalltracking.js","sourceRoot":"","sources":["../../../src/js/tracing/stalltracking.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport type { IdleTransaction, Span, Transaction } from '@sentry/core';\nimport type { Measurements, MeasurementUnit } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\nimport type { AppStateStatus } from 'react-native';\nimport { AppState } from 'react-native';\n\nimport { STALL_COUNT, STALL_LONGEST_TIME, STALL_TOTAL_TIME } from '../measurements';\n\nexport interface StallMeasurements extends Measurements {\n  [STALL_COUNT]: { value: number; unit: MeasurementUnit };\n  [STALL_TOTAL_TIME]: { value: number; unit: MeasurementUnit };\n  [STALL_LONGEST_TIME]: { value: number; unit: MeasurementUnit };\n}\n\nexport type StallTrackingOptions = {\n  /**\n   * How long in milliseconds an event loop iteration can be delayed for before being considered a \"stall.\"\n   * @default 100\n   */\n  minimumStallThreshold: number;\n};\n\n/** Margin of error of 20ms */\nconst MARGIN_OF_ERROR_SECONDS = 0.02;\n/** How long between each iteration in the event loop tracker timeout */\nconst LOOP_TIMEOUT_INTERVAL_MS = 50;\n/** Limit for how many transactions the stall tracker will track at a time to prevent leaks due to transactions not being finished */\nconst MAX_RUNNING_TRANSACTIONS = 10;\n\n/**\n * Stall measurement tracker inspired by the `JSEventLoopWatchdog` used internally in React Native:\n * https://github.com/facebook/react-native/blob/006f5afe120c290a37cf6ff896748fbc062bf7ed/Libraries/Interaction/JSEventLoopWatchdog.js\n *\n * However, we modified the interval implementation to instead have a fixed loop timeout interval of `LOOP_TIMEOUT_INTERVAL_MS`.\n * We then would consider that iteration a stall when the total time for that interval to run is greater than `LOOP_TIMEOUT_INTERVAL_MS + minimumStallThreshold`\n */\nexport class StallTrackingInstrumentation {\n  public isTracking: boolean = false;\n\n  private _minimumStallThreshold: number;\n\n  /** Total amount of time of all stalls that occurred during the current tracking session */\n  private _totalStallTime: number = 0;\n  /** Total number of stalls that occurred during the current tracking session */\n  private _stallCount: number = 0;\n\n  /** The last timestamp the iteration ran in milliseconds */\n  private _lastIntervalMs: number = 0;\n  private _timeout: ReturnType<typeof setTimeout> | null = null;\n\n  private _isBackground: boolean = false;\n\n  private _statsByTransaction: Map<\n    Transaction,\n    {\n      longestStallTime: number;\n      atStart: StallMeasurements;\n      atTimestamp: {\n        timestamp: number;\n        stats: StallMeasurements;\n      } | null;\n    }\n  > = new Map();\n\n  public constructor(options: StallTrackingOptions = { minimumStallThreshold: 50 }) {\n    this._minimumStallThreshold = options.minimumStallThreshold;\n\n    this._backgroundEventListener = this._backgroundEventListener.bind(this);\n    // Avoids throwing any error if using React Native on a environment that doesn't implement AppState.\n    if (AppState?.isAvailable) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      AppState.addEventListener('change', this._backgroundEventListener);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   * Not used for this integration. Instead call `registerTransactionStart` to start tracking.\n   */\n  public setupOnce(): void {\n    // Do nothing.\n  }\n\n  /**\n   * Register a transaction as started. Starts stall tracking if not already running.\n   * @returns A finish method that returns the stall measurements.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    if (this._statsByTransaction.has(transaction)) {\n      logger.error(\n        '[StallTracking] Tried to start stall tracking on a transaction already being tracked. Measurements might be lost.',\n      );\n\n      return;\n    }\n\n    this._startTracking();\n    this._statsByTransaction.set(transaction, {\n      longestStallTime: 0,\n      atTimestamp: null,\n      atStart: this._getCurrentStats(transaction),\n    });\n    this._flushLeakedTransactions();\n\n    if (transaction.spanRecorder) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const originalAdd = transaction.spanRecorder.add;\n\n      transaction.spanRecorder.add = (span: Span): void => {\n        originalAdd.apply(transaction.spanRecorder, [span]);\n\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        const originalSpanFinish = span.finish;\n\n        span.finish = (endTimestamp?: number) => {\n          // We let the span determine its own end timestamp as well in case anything gets changed upstream\n          originalSpanFinish.apply(span, [endTimestamp]);\n\n          // The span should set a timestamp, so this would be defined.\n          if (span.endTimestamp) {\n            this._markSpanFinish(transaction, span.endTimestamp);\n          }\n        };\n\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        const originalSpanEnd = span.end;\n\n        span.end = (endTimestamp?: number) => {\n          // We let the span determine its own end timestamp as well in case anything gets changed upstream\n          originalSpanEnd.apply(span, [endTimestamp]);\n\n          // The span should set a timestamp, so this would be defined.\n          if (span.endTimestamp) {\n            this._markSpanFinish(transaction, span.endTimestamp);\n          }\n        };\n      };\n    }\n  }\n\n  /**\n   * Logs a transaction as finished.\n   * Stops stall tracking if no more transactions are running.\n   * @returns The stall measurements\n   */\n  public onTransactionFinish(transaction: Transaction | IdleTransaction, passedEndTimestamp?: number): void {\n    const transactionStats = this._statsByTransaction.get(transaction);\n\n    if (!transactionStats) {\n      // Transaction has been flushed out somehow, we return null.\n      logger.log('[StallTracking] Stall measurements were not added to transaction due to exceeding the max count.');\n\n      this._statsByTransaction.delete(transaction);\n      this._shouldStopTracking();\n\n      return;\n    }\n\n    const endTimestamp = passedEndTimestamp ?? transaction.endTimestamp;\n\n    const spans = transaction.spanRecorder ? transaction.spanRecorder.spans : [];\n    const finishedSpanCount = spans.reduce((count, s) => (s !== transaction && s.endTimestamp ? count + 1 : count), 0);\n\n    const trimEnd = transaction.toContext().trimEnd;\n    const endWillBeTrimmed = trimEnd && finishedSpanCount > 0;\n\n    /*\n      This is not safe in the case that something changes upstream, but if we're planning to move this over to @sentry/javascript anyways,\n      we can have this temporarily for now.\n    */\n    const isIdleTransaction = 'activities' in transaction;\n\n    let statsOnFinish: StallMeasurements | undefined;\n    if (endTimestamp && isIdleTransaction) {\n      /*\n        There is different behavior regarding child spans in a normal transaction and an idle transaction. In normal transactions,\n        the child spans that aren't finished will be dumped, while in an idle transaction they're cancelled and finished.\n\n        Note: `endTimestamp` will always be defined if this is called on an idle transaction finish. This is because we only instrument\n        idle transactions inside `ReactNativeTracing`, which will pass an `endTimestamp`.\n      */\n\n      // There will be cancelled spans, which means that the end won't be trimmed\n      const spansWillBeCancelled = spans.some(\n        s => s !== transaction && s.startTimestamp < endTimestamp && !s.endTimestamp,\n      );\n\n      if (endWillBeTrimmed && !spansWillBeCancelled) {\n        // the last span's timestamp will be used.\n\n        if (transactionStats.atTimestamp) {\n          statsOnFinish = transactionStats.atTimestamp.stats;\n        }\n      } else {\n        // this endTimestamp will be used.\n        statsOnFinish = this._getCurrentStats(transaction);\n      }\n    } else if (endWillBeTrimmed) {\n      // If `trimEnd` is used, and there is a span to trim to. If there isn't, then the transaction should use `endTimestamp` or generate one.\n      if (transactionStats.atTimestamp) {\n        statsOnFinish = transactionStats.atTimestamp.stats;\n      }\n    } else if (!endTimestamp) {\n      statsOnFinish = this._getCurrentStats(transaction);\n    }\n\n    this._statsByTransaction.delete(transaction);\n    this._shouldStopTracking();\n\n    if (!statsOnFinish) {\n      if (typeof endTimestamp !== 'undefined') {\n        logger.log('[StallTracking] Stall measurements not added due to `endTimestamp` being set.');\n      } else if (trimEnd) {\n        logger.log(\n          '[StallTracking] Stall measurements not added due to `trimEnd` being set but we could not determine the stall measurements at that time.',\n        );\n      }\n\n      return;\n    }\n\n    transaction.setMeasurement(\n      STALL_COUNT,\n      statsOnFinish.stall_count.value - transactionStats.atStart.stall_count.value,\n      transactionStats.atStart.stall_count.unit,\n    );\n\n    transaction.setMeasurement(\n      STALL_TOTAL_TIME,\n      statsOnFinish.stall_total_time.value - transactionStats.atStart.stall_total_time.value,\n      transactionStats.atStart.stall_total_time.unit,\n    );\n\n    transaction.setMeasurement(\n      STALL_LONGEST_TIME,\n      statsOnFinish.stall_longest_time.value,\n      statsOnFinish.stall_longest_time.unit,\n    );\n  }\n\n  /**\n   * Switch that enables the iteraction once app moves from background to foreground.\n   */\n  private _backgroundEventListener(state: AppStateStatus): void {\n    if (state === ('active' as AppStateStatus)) {\n      this._isBackground = false;\n      if (this._timeout != null) {\n        this._lastIntervalMs = timestampInSeconds() * 1000;\n        this._iteration();\n      }\n    } else {\n      this._isBackground = true;\n      this._timeout !== null && clearTimeout(this._timeout);\n    }\n  }\n\n  /**\n   * Logs the finish time of the span for use in `trimEnd: true` transactions.\n   */\n  private _markSpanFinish(transaction: Transaction, spanEndTimestamp: number): void {\n    const previousStats = this._statsByTransaction.get(transaction);\n    if (previousStats) {\n      if (Math.abs(timestampInSeconds() - spanEndTimestamp) > MARGIN_OF_ERROR_SECONDS) {\n        logger.log(\n          '[StallTracking] Span end not logged due to end timestamp being outside the margin of error from now.',\n        );\n\n        if (previousStats.atTimestamp && previousStats.atTimestamp.timestamp < spanEndTimestamp) {\n          // We also need to delete the stat for the last span, as the transaction would be trimmed to this span not the last one.\n          this._statsByTransaction.set(transaction, {\n            ...previousStats,\n            atTimestamp: null,\n          });\n        }\n      } else {\n        this._statsByTransaction.set(transaction, {\n          ...previousStats,\n          atTimestamp: {\n            timestamp: spanEndTimestamp,\n            stats: this._getCurrentStats(transaction),\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the current stats for a transaction at a given time.\n   */\n  private _getCurrentStats(transaction: Transaction): StallMeasurements {\n    return {\n      stall_count: { value: this._stallCount, unit: 'none' },\n      stall_total_time: { value: this._totalStallTime, unit: 'millisecond' },\n      stall_longest_time: {\n        value: this._statsByTransaction.get(transaction)?.longestStallTime ?? 0,\n        unit: 'millisecond',\n      },\n    };\n  }\n\n  /**\n   * Start tracking stalls\n   */\n  private _startTracking(): void {\n    if (!this.isTracking) {\n      this.isTracking = true;\n      this._lastIntervalMs = Math.floor(timestampInSeconds() * 1000);\n\n      this._iteration();\n    }\n  }\n\n  /**\n   * Stops the stall tracking interval and calls reset().\n   */\n  private _stopTracking(): void {\n    this.isTracking = false;\n\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    this._reset();\n  }\n\n  /**\n   * Will stop tracking if there are no more transactions.\n   */\n  private _shouldStopTracking(): void {\n    if (this._statsByTransaction.size === 0) {\n      this._stopTracking();\n    }\n  }\n\n  /**\n   * Clears all the collected stats\n   */\n  private _reset(): void {\n    this._stallCount = 0;\n    this._totalStallTime = 0;\n    this._lastIntervalMs = 0;\n    this._statsByTransaction.clear();\n  }\n\n  /**\n   * Iteration of the stall tracking interval. Measures how long the timer strayed from its expected time of running, and how\n   * long the stall is for.\n   */\n  private _iteration(): void {\n    const now = timestampInSeconds() * 1000;\n    const totalTimeTaken = now - this._lastIntervalMs;\n\n    if (totalTimeTaken >= LOOP_TIMEOUT_INTERVAL_MS + this._minimumStallThreshold) {\n      const stallTime = totalTimeTaken - LOOP_TIMEOUT_INTERVAL_MS;\n      this._stallCount += 1;\n      this._totalStallTime += stallTime;\n\n      for (const [transaction, value] of this._statsByTransaction.entries()) {\n        const longestStallTime = Math.max(value.longestStallTime ?? 0, stallTime);\n\n        this._statsByTransaction.set(transaction, {\n          ...value,\n          longestStallTime,\n        });\n      }\n    }\n\n    this._lastIntervalMs = now;\n\n    if (this.isTracking && !this._isBackground) {\n      this._timeout = setTimeout(this._iteration.bind(this), LOOP_TIMEOUT_INTERVAL_MS);\n    }\n  }\n\n  /**\n   * Deletes leaked transactions (Earliest transactions when we have more than MAX_RUNNING_TRANSACTIONS transactions.)\n   */\n  private _flushLeakedTransactions(): void {\n    if (this._statsByTransaction.size > MAX_RUNNING_TRANSACTIONS) {\n      let counter = 0;\n      const len = this._statsByTransaction.size - MAX_RUNNING_TRANSACTIONS;\n      const transactions = this._statsByTransaction.keys();\n      for (const t of transactions) {\n        if (counter >= len) break;\n        counter += 1;\n        this._statsByTransaction.delete(t);\n      }\n    }\n  }\n}\n"]}